name: CD - Continuous Deployment

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      force_deploy:
        description: 'Force deployment (skip some checks)'
        required: false
        default: false
        type: boolean

env:
  NODE_VERSION: '18'
  AZURE_RESOURCE_GROUP_STAGING: 'helpsavta-staging-rg'
  AZURE_RESOURCE_GROUP_PRODUCTION: 'helpsavta-production-rg'
  AZURE_LOCATION: 'East US'

jobs:
  determine-environment:
    name: Determine Deployment Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      resource-group: ${{ steps.set-env.outputs.resource-group }}
      should-deploy: ${{ steps.set-env.outputs.should-deploy }}
    
    steps:
    - name: Set environment variables
      id: set-env
      run: |
        if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
          echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
        else
          echo "environment=staging" >> $GITHUB_OUTPUT
        fi
        
        ENV="${{ github.event.inputs.environment || 'staging' }}"
        if [ "$ENV" == "production" ]; then
          echo "resource-group=${{ env.AZURE_RESOURCE_GROUP_PRODUCTION }}" >> $GITHUB_OUTPUT
        else
          echo "resource-group=${{ env.AZURE_RESOURCE_GROUP_STAGING }}" >> $GITHUB_OUTPUT
        fi
        
        # Only deploy if CI passed or force deploy is enabled
        if [ "${{ github.event.inputs.force_deploy }}" == "true" ] || [ "${{ github.event_name }}" == "push" ]; then
          echo "should-deploy=true" >> $GITHUB_OUTPUT
        else
          echo "should-deploy=false" >> $GITHUB_OUTPUT
        fi

  build-and-push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    needs: determine-environment
    if: needs.determine-environment.outputs.should-deploy == 'true'
    
    outputs:
      backend-image: ${{ steps.meta-backend.outputs.tags }}
      frontend-image: ${{ steps.meta-frontend.outputs.tags }}
      backend-digest: ${{ steps.build-backend.outputs.digest }}
      frontend-digest: ${{ steps.build-frontend.outputs.digest }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Azure Container Registry
      uses: azure/docker-login@v1
      with:
        login-server: ${{ secrets.AZURE_CONTAINER_REGISTRY }}
        username: ${{ secrets.AZURE_CONTAINER_REGISTRY_USERNAME }}
        password: ${{ secrets.AZURE_CONTAINER_REGISTRY_PASSWORD }}

    - name: Extract metadata for backend
      id: meta-backend
      uses: docker/metadata-action@v5
      with:
        images: ${{ secrets.AZURE_CONTAINER_REGISTRY }}/helpsavta-backend
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Extract metadata for frontend
      id: meta-frontend
      uses: docker/metadata-action@v5
      with:
        images: ${{ secrets.AZURE_CONTAINER_REGISTRY }}/helpsavta-frontend
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push backend image
      id: build-backend
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        push: true
        tags: ${{ steps.meta-backend.outputs.tags }}
        labels: ${{ steps.meta-backend.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64

    - name: Build and push frontend image
      id: build-frontend
      uses: docker/build-push-action@v5
      with:
        context: ./frontend
        file: ./frontend/Dockerfile
        push: true
        tags: ${{ steps.meta-frontend.outputs.tags }}
        labels: ${{ steps.meta-frontend.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64

  deploy-to-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [determine-environment, build-and-push]
    if: needs.determine-environment.outputs.should-deploy == 'true'
    environment: 
      name: staging
      url: ${{ steps.deploy.outputs.staging-url }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Set Azure subscription
      run: az account set --subscription ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Deploy Azure infrastructure
      id: deploy-infra
      run: |
        DEPLOYMENT_NAME="helpsavta-deployment-$(date +%Y%m%d-%H%M%S)"
        
        az deployment group create \
          --resource-group ${{ needs.determine-environment.outputs.resource-group }} \
          --template-file azure/main.bicep \
          --parameters @azure/parameters.staging.json \
          --name $DEPLOYMENT_NAME \
          --verbose
        
        echo "deployment-name=$DEPLOYMENT_NAME" >> $GITHUB_OUTPUT

    - name: Get deployment outputs
      id: outputs
      run: |
        WEBAPP_NAME=$(az deployment group show \
          --resource-group ${{ needs.determine-environment.outputs.resource-group }} \
          --name ${{ steps.deploy-infra.outputs.deployment-name }} \
          --query 'properties.outputs.webAppName.value' \
          --output tsv)
        
        CONTAINER_REGISTRY=$(az deployment group show \
          --resource-group ${{ needs.determine-environment.outputs.resource-group }} \
          --name ${{ steps.deploy-infra.outputs.deployment-name }} \
          --query 'properties.outputs.containerRegistryLoginServer.value' \
          --output tsv)
        
        echo "webapp-name=$WEBAPP_NAME" >> $GITHUB_OUTPUT
        echo "container-registry=$CONTAINER_REGISTRY" >> $GITHUB_OUTPUT

    - name: Run database migrations
      run: |
        # Set database connection for staging
        echo "Running database migrations for staging..."
        cd backend
        
        # Use staging database URL from Azure Key Vault or secrets
        export DATABASE_URL="${{ secrets.STAGING_DATABASE_URL }}"
        npx prisma migrate deploy

    - name: Deploy to staging slot
      id: deploy
      run: |
        WEBAPP_NAME="${{ steps.outputs.outputs.webapp-name }}"
        CONTAINER_REGISTRY="${{ steps.outputs.outputs.container-registry }}"
        
        # Update backend container
        az webapp config container set \
          --name $WEBAPP_NAME \
          --resource-group ${{ needs.determine-environment.outputs.resource-group }} \
          --slot staging \
          --docker-custom-image-name $CONTAINER_REGISTRY/helpsavta-backend:latest \
          --docker-registry-server-url https://$CONTAINER_REGISTRY
        
        # Restart staging slot
        az webapp restart \
          --name $WEBAPP_NAME \
          --resource-group ${{ needs.determine-environment.outputs.resource-group }} \
          --slot staging
        
        STAGING_URL="https://${WEBAPP_NAME}-staging.azurewebsites.net"
        echo "staging-url=$STAGING_URL" >> $GITHUB_OUTPUT
        
        # Wait for deployment
        echo "Waiting for deployment to complete..."
        sleep 60

    - name: Run staging smoke tests
      run: |
        chmod +x scripts/smoke-tests.sh
        ./scripts/smoke-tests.sh ${{ steps.deploy.outputs.staging-url }}

    - name: Update deployment status
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "✅ Staging deployment successful: ${{ steps.deploy.outputs.staging-url }}"
        else
          echo "❌ Staging deployment failed"
          exit 1
        fi

  deploy-to-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [determine-environment, build-and-push, deploy-to-staging]
    if: needs.determine-environment.outputs.environment == 'production' && needs.determine-environment.outputs.should-deploy == 'true'
    environment: 
      name: production
      url: ${{ steps.production-swap.outputs.production-url }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Get staging deployment info
      id: staging-info
      run: |
        WEBAPP_NAME=$(az deployment group show \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP_PRODUCTION }} \
          --name ${{ needs.deploy-to-staging.outputs.deployment-name }} \
          --query 'properties.outputs.webAppName.value' \
          --output tsv)
        
        echo "webapp-name=$WEBAPP_NAME" >> $GITHUB_OUTPUT

    - name: Run production database migrations
      run: |
        echo "Running production database migrations..."
        chmod +x scripts/migrate-production.sh
        export DATABASE_URL="${{ secrets.PRODUCTION_DATABASE_URL }}"
        ./scripts/migrate-production.sh

    - name: Swap staging to production
      id: production-swap
      run: |
        WEBAPP_NAME="${{ steps.staging-info.outputs.webapp-name }}"
        
        echo "Swapping staging slot to production..."
        az webapp deployment slot swap \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP_PRODUCTION }} \
          --name $WEBAPP_NAME \
          --slot staging \
          --target-slot production
        
        PRODUCTION_URL="https://${WEBAPP_NAME}.azurewebsites.net"
        echo "production-url=$PRODUCTION_URL" >> $GITHUB_OUTPUT
        
        # Wait for swap to complete
        echo "Waiting for production swap to complete..."
        sleep 30

    - name: Run production smoke tests
      run: |
        chmod +x scripts/smoke-tests.sh
        ./scripts/smoke-tests.sh ${{ steps.production-swap.outputs.production-url }}

    - name: Rollback on failure
      if: failure()
      run: |
        echo "Production deployment failed, initiating rollback..."
        WEBAPP_NAME="${{ steps.staging-info.outputs.webapp-name }}"
        
        # Swap back to previous version
        az webapp deployment slot swap \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP_PRODUCTION }} \
          --name $WEBAPP_NAME \
          --slot production \
          --target-slot staging
        
        echo "Rollback completed"

    - name: Update deployment status
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "✅ Production deployment successful: ${{ steps.production-swap.outputs.production-url }}"
        else
          echo "❌ Production deployment failed and rolled back"
          exit 1
        fi

  cleanup:
    name: Cleanup
    runs-on: ubuntu-latest
    needs: [determine-environment, build-and-push, deploy-to-staging]
    if: always() && needs.determine-environment.outputs.should-deploy == 'true'
    
    steps:
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Cleanup old container images
      run: |
        echo "Cleaning up old container images..."
        # Keep last 5 versions of each image
        REGISTRY="${{ secrets.AZURE_CONTAINER_REGISTRY }}"
        
        # Cleanup backend images
        az acr repository show-tags \
          --name ${REGISTRY} \
          --repository helpsavta-backend \
          --orderby time_desc \
          --output tsv | tail -n +6 | \
        while read tag; do
          if [ -n "$tag" ] && [ "$tag" != "latest" ]; then
            echo "Deleting old backend image: $tag"
            az acr repository delete \
              --name ${REGISTRY} \
              --image helpsavta-backend:$tag \
              --yes || true
          fi
        done
        
        # Cleanup frontend images
        az acr repository show-tags \
          --name ${REGISTRY} \
          --repository helpsavta-frontend \
          --orderby time_desc \
          --output tsv | tail -n +6 | \
        while read tag; do
          if [ -n "$tag" ] && [ "$tag" != "latest" ]; then
            echo "Deleting old frontend image: $tag"
            az acr repository delete \
              --name ${REGISTRY} \
              --image helpsavta-frontend:$tag \
              --yes || true
          fi
        done