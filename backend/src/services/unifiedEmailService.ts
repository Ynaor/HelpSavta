import nodemailer from 'nodemailer';
import sgMail from '@sendgrid/mail';
import { prisma } from '../server';
import { renderEmailTemplate } from '../config/emailTemplateConfig';

interface EmailProvider {
  name: string;
  send(emailData: EmailData): Promise<boolean>;
  testConnection(): Promise<boolean>;
  isReady(): boolean;
}

interface EmailData {
  to: string;
  subject: string;
  text: string;
  html: string;
  replyTo?: string;
  metadata?: Record<string, any>;
}

interface SMTPConfig {
  host: string;
  port: number;
  secure: boolean;
  auth: {
    user: string;
    pass: string;
  };
}

interface SendGridConfig {
  apiKey: string;
  fromEmail: string;
  fromName: string;
  replyToEmail?: string;
}

class SMTPProvider implements EmailProvider {
  name = 'SMTP';
  private transporter: nodemailer.Transporter | null = null;
  private config: SMTPConfig | null = null;

  constructor() {
    this.initialize();
  }

  private initialize(): void {
    try {
      const emailHost = process.env.EMAIL_HOST;
      const emailPort = process.env.EMAIL_PORT;
      const emailUser = process.env.EMAIL_USER;
      const emailPass = process.env.EMAIL_PASS;

      if (!emailHost || !emailPort || !emailUser || !emailPass) {
        console.log('üìß SMTP not configured - missing environment variables');
        return;
      }

      this.config = {
        host: emailHost,
        port: parseInt(emailPort),
        secure: parseInt(emailPort) === 465,
        auth: {
          user: emailUser,
          pass: emailPass
        }
      };

      this.transporter = nodemailer.createTransport(this.config);
      console.log('üìß SMTP provider configured successfully');
    } catch (error) {
      console.error('‚ùå Failed to configure SMTP provider:', error);
    }
  }

  async send(emailData: EmailData): Promise<boolean> {
    if (!this.transporter) return false;

    try {
      const mailOptions = {
        from: `"Help Savta" <${process.env.EMAIL_USER}>`,
        to: emailData.to,
        subject: emailData.subject,
        text: emailData.text,
        html: emailData.html,
        replyTo: emailData.replyTo
      };

      await this.transporter.sendMail(mailOptions);
      console.log(`üìß SMTP: Email sent successfully to ${emailData.to}`);
      return true;
    } catch (error) {
      console.error('‚ùå SMTP send failed:', error);
      return false;
    }
  }

  async testConnection(): Promise<boolean> {
    if (!this.transporter) return false;

    try {
      await this.transporter.verify();
      console.log('üìß SMTP connection test successful');
      return true;
    } catch (error) {
      console.error('‚ùå SMTP connection test failed:', error);
      return false;
    }
  }

  isReady(): boolean {
    return this.transporter !== null;
  }
}

class SendGridProvider implements EmailProvider {
  name = 'SendGrid';
  private config: SendGridConfig | null = null;

  constructor() {
    this.initialize();
  }

  private initialize(): void {
    try {
      const apiKey = process.env.SENDGRID_API_KEY;
      const fromEmail = process.env.EMAIL_FROM || process.env.EMAIL_USER || 'noreply@helpsavta.com';
      const fromName = process.env.EMAIL_FROM_NAME || 'Help Savta';
      const replyToEmail = process.env.EMAIL_REPLY_TO || process.env.SUPPORT_EMAIL;

      if (!apiKey) {
        console.log('üìß SendGrid not configured - missing SENDGRID_API_KEY');
        return;
      }

      if (!apiKey.startsWith('SG.')) {
        console.warn('‚ö†Ô∏è SendGrid API key format may be invalid (should start with "SG.")');
      }

      sgMail.setApiKey(apiKey);

      this.config = {
        apiKey,
        fromEmail,
        fromName,
        replyToEmail
      };

      console.log('üìß SendGrid provider configured successfully');
    } catch (error) {
      console.error('‚ùå Failed to configure SendGrid provider:', error);
    }
  }

  async send(emailData: EmailData): Promise<boolean> {
    if (!this.config) return false;

    try {
      const msg = {
        to: emailData.to,
        from: {
          email: this.config.fromEmail,
          name: this.config.fromName
        },
        replyTo: emailData.replyTo || this.config.replyToEmail,
        subject: emailData.subject,
        text: emailData.text,
        html: emailData.html,
        trackingSettings: {
          clickTracking: { enable: false },
          openTracking: { enable: false }
        },
        customArgs: emailData.metadata || {}
      };

      await sgMail.send(msg);
      console.log(`üìß SendGrid: Email sent successfully to ${emailData.to}`);
      return true;
    } catch (error) {
      console.error('‚ùå SendGrid send failed:', error);
      return false;
    }
  }

  async testConnection(): Promise<boolean> {
    if (!this.config) return false;

    try {
      const testMsg = {
        to: 'test@invalid-domain-for-testing.invalid',
        from: this.config.fromEmail,
        subject: 'Connection Test',
        text: 'This is a connection test'
      };

      try {
        await sgMail.send(testMsg);
        return true;
      } catch (error: any) {
        if (error.code && error.code >= 400 && error.code < 500) {
          console.log('üìß SendGrid connection test successful (API responded)');
          return true;
        }
        throw error;
      }
    } catch (error) {
      console.error('‚ùå SendGrid connection test failed:', error);
      return false;
    }
  }

  isReady(): boolean {
    return this.config !== null;
  }
}

class UnifiedEmailService {
  private providers: EmailProvider[] = [];
  private primaryProvider: EmailProvider | null = null;

  constructor() {
    this.initializeProviders();
  }

  private initializeProviders(): void {
    const sendGridProvider = new SendGridProvider();
    const smtpProvider = new SMTPProvider();

    // Add providers in priority order (SendGrid first, SMTP as fallback)
    if (sendGridProvider.isReady()) {
      this.providers.push(sendGridProvider);
      this.primaryProvider = sendGridProvider;
    }

    if (smtpProvider.isReady()) {
      this.providers.push(smtpProvider);
      if (!this.primaryProvider) {
        this.primaryProvider = smtpProvider;
      }
    }

    console.log(`üìß Unified email service initialized with ${this.providers.length} provider(s)`);
    if (this.primaryProvider) {
      console.log(`üìß Primary provider: ${this.primaryProvider.name}`);
    }
  }

  private async sendWithFallback(emailData: EmailData): Promise<boolean> {
    for (const provider of this.providers) {
      console.log(`üìß Attempting to send email via ${provider.name}`);
      const success = await provider.send(emailData);
      
      if (success) {
        await this.logNotification('email', emailData.to, 
          `Email sent via ${provider.name}`, 'sent');
        return true;
      }
      
      console.log(`üìß ${provider.name} failed, trying next provider...`);
    }

    await this.logNotification('email', emailData.to, 
      'All email providers failed', 'failed');
    return false;
  }

  async sendRequestCreatedEmail(request: any): Promise<boolean> {
    if (!this.isReady()) {
      await this.logNotification('email', request.email,
        `Request created email for #${request.id}`, 'not_sent');
      return false;
    }

    try {
      const emailContent = await renderEmailTemplate('request-created', request);
      if (!emailContent) {
        console.warn('‚ö†Ô∏è Failed to render template - falling back to basic email');
        return await this.sendBasicRequestCreatedEmail(request);
      }

      const emailData: EmailData = {
        to: request.email,
        subject: emailContent.subject,
        text: emailContent.text,
        html: emailContent.html,
        metadata: {
          requestId: request.id.toString(),
          templateType: 'request-created'
        }
      };

      return await this.sendWithFallback(emailData);
    } catch (error) {
      console.error('‚ùå Failed to send request created email:', error);
      return false;
    }
  }

  async sendStatusUpdateEmail(request: any, admin?: any): Promise<boolean> {
    if (!this.isReady()) {
      await this.logNotification('email', request.email,
        `Status update email for #${request.id}`, 'not_sent');
      return false;
    }

    try {
      const emailContent = await renderEmailTemplate('status-update', request, admin);
      if (!emailContent) {
        console.warn('‚ö†Ô∏è Failed to render template - using legacy method');
        return await this.sendLegacyStatusUpdateEmail(request.email, request.full_name, request.id.toString(), request.status);
      }

      const emailData: EmailData = {
        to: request.email,
        subject: emailContent.subject,
        text: emailContent.text,
        html: emailContent.html,
        metadata: {
          requestId: request.id.toString(),
          templateType: 'status-update'
        }
      };

      return await this.sendWithFallback(emailData);
    } catch (error) {
      console.error('‚ùå Failed to send status update email:', error);
      return false;
    }
  }

  async sendRequestCompletedEmail(request: any, admin?: any, slot?: any): Promise<boolean> {
    if (!this.isReady()) {
      await this.logNotification('email', request.email,
        `Request completed email for #${request.id}`, 'not_sent');
      return false;
    }

    try {
      const emailContent = await renderEmailTemplate('request-completed', request, admin, slot);
      if (!emailContent) {
        console.warn('‚ö†Ô∏è Failed to render template - falling back to basic email');
        return await this.sendBasicCompletedEmail(request, admin, slot);
      }

      const emailData: EmailData = {
        to: request.email,
        subject: emailContent.subject,
        text: emailContent.text,
        html: emailContent.html,
        metadata: {
          requestId: request.id.toString(),
          templateType: 'request-completed'
        }
      };

      return await this.sendWithFallback(emailData);
    } catch (error) {
      console.error('‚ùå Failed to send request completed email:', error);
      return false;
    }
  }

  async sendEmailVerification(email: string, verificationToken: string, baseUrl: string): Promise<boolean> {
    if (!this.isReady()) {
      console.log('üìß Email service not configured - cannot send verification email');
      return false;
    }

    try {
      const verificationUrl = `${baseUrl}/verify-email?token=${verificationToken}`;
      
      const subject = '◊ê◊ô◊û◊ï◊™ ◊õ◊™◊ï◊ë◊™ ◊ê◊ô◊û◊ô◊ô◊ú - Help Savta';
      const htmlContent = `
        <div dir="rtl" style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2 style="color: #2563eb;">◊ê◊ô◊û◊ï◊™ ◊õ◊™◊ï◊ë◊™ ◊ê◊ô◊û◊ô◊ô◊ú</h2>
          <p>◊ú◊ó◊• ◊¢◊ú ◊î◊ß◊ô◊©◊ï◊® ◊î◊ë◊ê ◊ú◊ê◊ô◊û◊ï◊™ ◊õ◊™◊ï◊ë◊™ ◊î◊ê◊ô◊û◊ô◊ô◊ú ◊©◊ú◊ö:</p>
          <div style="text-align: center; margin: 20px 0;">
            <a href="${verificationUrl}" style="background-color: #2563eb; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px;">
              ◊ê◊û◊™ ◊ê◊ô◊û◊ô◊ô◊ú
            </a>
          </div>
          <p>◊ê◊ù ◊ú◊ê ◊ë◊ô◊ß◊©◊™ ◊ê◊ô◊û◊ï◊™ ◊ñ◊î, ◊ê◊†◊ê ◊î◊™◊¢◊ú◊ù ◊û◊ê◊ô◊û◊ô◊ô◊ú ◊ñ◊î.</p>
          <p>◊ë◊ë◊®◊õ◊î,<br>◊¶◊ï◊ï◊™ Help Savta</p>
        </div>
      `;

      const textContent = `
◊ê◊ô◊û◊ï◊™ ◊õ◊™◊ï◊ë◊™ ◊ê◊ô◊û◊ô◊ô◊ú - Help Savta

◊ú◊ê◊ô◊û◊ï◊™ ◊õ◊™◊ï◊ë◊™ ◊î◊ê◊ô◊û◊ô◊ô◊ú ◊©◊ú◊ö, ◊¢◊ë◊ï◊® ◊ú◊ß◊ô◊©◊ï◊® ◊î◊ë◊ê:
${verificationUrl}

◊ê◊ù ◊ú◊ê ◊ë◊ô◊ß◊©◊™ ◊ê◊ô◊û◊ï◊™ ◊ñ◊î, ◊ê◊†◊ê ◊î◊™◊¢◊ú◊ù ◊û◊ê◊ô◊û◊ô◊ô◊ú ◊ñ◊î.

◊ë◊ë◊®◊õ◊î,
◊¶◊ï◊ï◊™ Help Savta
      `;

      const emailData: EmailData = {
        to: email,
        subject,
        text: textContent,
        html: htmlContent,
        metadata: {
          templateType: 'email-verification'
        }
      };

      return await this.sendWithFallback(emailData);
    } catch (error) {
      console.error('‚ùå Failed to send verification email:', error);
      return false;
    }
  }

  async sendTestEmail(templateType: 'request-created' | 'status-update' | 'request-completed' | 'basic', recipientEmail: string): Promise<boolean> {
    if (!this.isReady()) {
      console.log('üìß Email service not configured - cannot send test email');
      return false;
    }

    try {
      if (templateType === 'basic') {
        const emailData: EmailData = {
          to: recipientEmail,
          subject: '[◊ë◊ì◊ô◊ß◊î] Unified Email Service - Help Savta',
          text: '◊ñ◊î◊ï ◊ê◊ô◊û◊ô◊ô◊ú ◊ë◊ì◊ô◊ß◊î ◊û◊î◊©◊ô◊®◊ï◊™ ◊î◊û◊ê◊ï◊ó◊ì ◊©◊ú Help Savta!',
          html: `
            <div dir="rtl" style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
              <h2 style="color: #2563eb;">‚úÖ ◊©◊ô◊®◊ï◊™ ◊î◊ê◊ô◊û◊ô◊ô◊ú ◊î◊û◊ê◊ï◊ó◊ì ◊§◊ï◊¢◊ú!</h2>
              <p>◊ñ◊î◊ï ◊ê◊ô◊û◊ô◊ô◊ú ◊ë◊ì◊ô◊ß◊î ◊û◊î◊©◊ô◊®◊ï◊™ ◊î◊û◊ê◊ï◊ó◊ì ◊¢◊ù ◊™◊û◊ô◊õ◊î ◊ë-SendGrid ◊ï-SMTP.</p>
              <p>◊™◊ê◊®◊ô◊ö ◊ë◊ì◊ô◊ß◊î: ${new Date().toLocaleString('he-IL')}</p>
              <p>◊ë◊ë◊®◊õ◊î,<br>◊¶◊ï◊ï◊™ Help Savta</p>
            </div>
          `,
          metadata: {
            templateType: 'test-basic'
          }
        };

        return await this.sendWithFallback(emailData);
      } else {
        // Use template-based test email
        const mockRequest = {
          id: 999,
          full_name: '◊û◊©◊™◊û◊© ◊ë◊ì◊ô◊ß◊î',
          phone: '050-9999999',
          email: recipientEmail,
          address: '◊õ◊™◊ï◊ë◊™ ◊ë◊ì◊ô◊ß◊î 123, ◊¢◊ô◊® ◊î◊ë◊ì◊ô◊ß◊î',
          problem_description: '◊ñ◊î◊ï ◊ê◊ô◊û◊ô◊ô◊ú ◊ë◊ì◊ô◊ß◊î ◊ú◊û◊¢◊®◊õ◊™ Help Savta.',
          urgency_level: 'medium',
          status: templateType === 'request-created' ? 'pending' : 'in_progress',
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
          notes: '◊ñ◊î◊ï ◊ê◊ô◊û◊ô◊ô◊ú ◊ë◊ì◊ô◊ß◊î - ◊ú◊ê ◊û◊ì◊ï◊ë◊® ◊ë◊ë◊ß◊©◊î ◊ê◊û◊ô◊™◊ô◊™'
        };

        switch (templateType) {
          case 'request-created':
            return await this.sendRequestCreatedEmail(mockRequest);
          case 'status-update':
            return await this.sendStatusUpdateEmail(mockRequest, { id: 999, username: '◊û◊™◊†◊ì◊ë ◊ë◊ì◊ô◊ß◊î' });
          case 'request-completed':
            return await this.sendRequestCompletedEmail(mockRequest, { id: 999, username: '◊û◊™◊†◊ì◊ë ◊ë◊ì◊ô◊ß◊î' }, 
              { id: 999, date: new Date().toISOString().split('T')[0], start_time: '10:00', end_time: '12:00' });
        }
      }
    } catch (error) {
      console.error('‚ùå Failed to send test email:', error);
      return false;
    }
  }

  // Basic email fallback methods
  private async sendBasicRequestCreatedEmail(request: any): Promise<boolean> {
    const emailData: EmailData = {
      to: request.email,
      subject: `◊ë◊ß◊©◊î #${request.id} ◊î◊™◊ß◊ë◊ú◊î - Help Savta`,
      text: `◊©◊ú◊ï◊ù ${request.full_name},\n\n◊™◊ï◊ì◊î ◊¢◊ú ◊§◊†◊ô◊ô◊™◊ö ◊ú◊©◊ô◊®◊ï◊™ Help Savta!\n\n◊û◊°◊§◊® ◊ë◊ß◊©◊î: #${request.id}\n◊™◊ô◊ê◊ï◊® ◊î◊ë◊¢◊ô◊î: ${request.problem_description}\n\n◊†◊ó◊ñ◊ï◊® ◊ê◊ú◊ô◊ö ◊ë◊î◊ß◊ì◊ù ◊î◊ê◊§◊©◊®◊ô.\n\n◊ë◊ë◊®◊õ◊î,\n◊¶◊ï◊ï◊™ Help Savta`,
      html: `
        <div dir="rtl" style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2 style="color: #2563eb;">◊©◊ú◊ï◊ù ${request.full_name},</h2>
          <p>◊™◊ï◊ì◊î ◊¢◊ú ◊§◊†◊ô◊ô◊™◊ö ◊ú◊©◊ô◊®◊ï◊™ Help Savta!</p>
          <div style="background-color: #f3f4f6; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h3>◊§◊®◊ò◊ô ◊î◊ë◊ß◊©◊î:</h3>
            <p><strong>◊û◊°◊§◊® ◊ë◊ß◊©◊î:</strong> #${request.id}</p>
            <p><strong>◊™◊ô◊ê◊ï◊® ◊î◊ë◊¢◊ô◊î:</strong> ${request.problem_description}</p>
          </div>
          <p>◊†◊ó◊ñ◊ï◊® ◊ê◊ú◊ô◊ö ◊ë◊î◊ß◊ì◊ù ◊î◊ê◊§◊©◊®◊ô.</p>
          <p>◊ë◊ë◊®◊õ◊î,<br>◊¶◊ï◊ï◊™ Help Savta</p>
        </div>
      `
    };

    return await this.sendWithFallback(emailData);
  }

  private async sendBasicCompletedEmail(request: any, admin?: any, slot?: any): Promise<boolean> {
    const emailData: EmailData = {
      to: request.email,
      subject: `◊ë◊ß◊©◊î #${request.id} ◊î◊ï◊©◊ú◊û◊î - Help Savta`,
      text: `◊©◊ú◊ï◊ù ${request.full_name},\n\n◊ê◊†◊ï ◊©◊û◊ó◊ô◊ù ◊ú◊¢◊ì◊õ◊ü ◊ê◊ï◊™◊ö ◊©◊î◊ë◊ß◊©◊î ◊©◊ú◊ö ◊î◊ï◊©◊ú◊û◊î ◊ë◊î◊¶◊ú◊ó◊î!\n\n◊û◊°◊§◊® ◊ë◊ß◊©◊î: #${request.id}\n${admin ? `◊î◊û◊™◊†◊ì◊ë ◊©◊ò◊ô◊§◊ú: ${admin.username}` : ''}\n\n◊™◊ï◊ì◊î ◊©◊ë◊ó◊®◊™ ◊ë◊©◊ô◊®◊ï◊™ Help Savta!\n\n◊ë◊ë◊®◊õ◊î,\n◊¶◊ï◊ï◊™ Help Savta`,
      html: `
        <div dir="rtl" style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2 style="color: #2563eb;">◊©◊ú◊ï◊ù ${request.full_name},</h2>
          <p>◊ê◊†◊ï ◊©◊û◊ó◊ô◊ù ◊ú◊¢◊ì◊õ◊ü ◊ê◊ï◊™◊ö ◊©◊î◊ë◊ß◊©◊î ◊©◊ú◊ö ◊î◊ï◊©◊ú◊û◊î ◊ë◊î◊¶◊ú◊ó◊î!</p>
          <div style="background-color: #f0fdf4; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h3>‚úÖ ◊ë◊ß◊©◊î ◊î◊ï◊©◊ú◊û◊î</h3>
            <p><strong>◊û◊°◊§◊® ◊ë◊ß◊©◊î:</strong> #${request.id}</p>
            ${admin ? `<p><strong>◊î◊û◊™◊†◊ì◊ë ◊©◊ò◊ô◊§◊ú:</strong> ${admin.username}</p>` : ''}
          </div>
          <p>◊™◊ï◊ì◊î ◊©◊ë◊ó◊®◊™ ◊ë◊©◊ô◊®◊ï◊™ Help Savta!</p>
          <p>◊ë◊ë◊®◊õ◊î,<br>◊¶◊ï◊ï◊™ Help Savta</p>
        </div>
      `
    };

    return await this.sendWithFallback(emailData);
  }

  // Legacy method compatibility
  private async sendLegacyStatusUpdateEmail(recipientEmail: string, recipientName: string, requestId: string, newStatus: string): Promise<boolean> {
    const emailData: EmailData = {
      to: recipientEmail,
      subject: '◊¢◊ì◊õ◊ï◊ü ◊°◊ò◊ò◊ï◊° ◊ë◊ß◊©◊î - Help Savta',
      text: `◊©◊ú◊ï◊ù ${recipientName},\n\n◊ê◊†◊ï ◊©◊û◊ó◊ô◊ù ◊ú◊¢◊ì◊õ◊ü ◊ê◊ï◊™◊ö ◊©◊ë◊ß◊©◊™◊ö ◊ú◊¢◊ñ◊®◊î ◊ò◊õ◊†◊ô◊™ ◊î◊ó◊ú◊î ◊ú◊î◊ô◊ï◊™ ◊û◊ò◊ï◊§◊ú◊™!\n\n◊û◊°◊§◊® ◊ë◊ß◊©◊î: #${requestId}\n◊°◊ò◊ò◊ï◊° ◊ó◊ì◊©: ${newStatus}\n\n◊ë◊ë◊®◊õ◊î,\n◊¶◊ï◊ï◊™ Help Savta`,
      html: `
        <div dir="rtl" style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2 style="color: #2563eb;">◊©◊ú◊ï◊ù ${recipientName},</h2>
          <p>◊ê◊†◊ï ◊©◊û◊ó◊ô◊ù ◊ú◊¢◊ì◊õ◊ü ◊ê◊ï◊™◊ö ◊©◊ë◊ß◊©◊™◊ö ◊ú◊¢◊ñ◊®◊î ◊ò◊õ◊†◊ô◊™ ◊î◊ó◊ú◊î ◊ú◊î◊ô◊ï◊™ ◊û◊ò◊ï◊§◊ú◊™!</p>
          <div style="background-color: #f0fdf4; padding: 20px; border-radius: 8px; margin: 20px 0; border-right: 4px solid #22c55e;">
            <h3 style="color: #15803d; margin-top: 0;">‚úÖ ◊î◊ë◊ß◊©◊î ◊ë◊ò◊ô◊§◊ï◊ú</h3>
            <p><strong>◊û◊°◊§◊® ◊ë◊ß◊©◊î:</strong> #${requestId}</p>
            <p><strong>◊°◊ò◊ò◊ï◊° ◊ó◊ì◊©:</strong> ${newStatus}</p>
          </div>
          <p>◊ë◊ë◊®◊õ◊î,<br>◊¶◊ï◊ï◊™ Help Savta</p>
        </div>
      `
    };

    return await this.sendWithFallback(emailData);
  }

  private async logNotification(
    type: string,
    recipient: string,
    message: string,
    status: 'pending' | 'sent' | 'failed' | 'not_sent'
  ): Promise<void> {
    try {
      await prisma.notificationLog.create({
        data: {
          type,
          recipient,
          message,
          status
        }
      });
    } catch (error) {
      console.error('‚ùå Failed to log notification:', error);
    }
  }

  isReady(): boolean {
    return this.providers.length > 0;
  }

  async testConnection(): Promise<boolean> {
    if (!this.primaryProvider) return false;
    return await this.primaryProvider.testConnection();
  }

  getProviders(): string[] {
    return this.providers.map(p => p.name);
  }
}

// Export singleton instance
export const unifiedEmailService = new UnifiedEmailService();

// Legacy exports for backward compatibility
export { unifiedEmailService as emailService };
export { unifiedEmailService as sendGridService };